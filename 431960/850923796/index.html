<html>
	<head>
		<style>
			html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; background: black; }		
			canvas { position: fixed; top: 0; left; 0; }
			#canvas { display: block; }
			#canvasBg { filter: blur( 10px ); }
			#fps { position: absolute; top: 0; left: 0; padding: 10px; color: white; z-index: 10000; }	
			#cpu-warning { display: none; position: absolute; top: 0; left: 0; right: 0; background: black; padding: 50px; color: white; text-align: center; font-family: sans-serif; font-size: 1.5em;}
			#cpu-warning h2 {color: red;}
		</style>
		<style>
			#background-wrapper { position: fixed; width: 100%; height: 100%; top: 0; left: 0; }
			#background-image1 { position: absolute; width: 100%; height: 100%; top: 0; left: 0;  }	
			#background-image2 { position: absolute; width: 100%; height: 100%; top: 0; left: 0; }	
			#background-image1-wrapper { position: absolute; width: 100%; height: 100%; top: 0; left: 0;  }	
			#background-image2-wrapper { position: absolute; width: 100%; height: 100%; top: 0; left: 0;  }	
		</style>
		<style>
			.radial-menu 
			{
				position: fixed;
				display: table-cell;
				text-align: center;
				vertical-align: center;
				line-height: 50px;
				cursor: pointer;
				user-select: none;
				width: 50px;
				height: 50px;
				background-position: center center;
				background-repeat: no-repeat;
				background-size: contain;
				background: #404040;
				border-radius: 50px;
				border: 1px solid white;
				color: white;	
				
			}
			.radial-menu-root
			{	
			}
			.radial-menu-item 
			{
				
			}
			
			#svg-panel {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				background: black;
				color: white;
				font-family: sans-serif;
				padding: 10px;
				border: 1px solid silver;
			}
			#svg-panel td {
				color: white;
			}
			
			#svg-progress-wrapper {
				width: 100%;
				background: #800;
				height: 20px;
			}
			#svg-progress {
				background: #080;
				height: 20px;
			}
			
			#edit-panel {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				background: black;
				color: white;
				font-family: sans-serif;
				padding: 10px;
				border: 1px solid silver;
			}
			#edit-panel table {
			}
			#edit-panel td {
				color: white;
			}
			#edit-panel button {
				width: 24px; 
				height: 24px;
				font-size: 20px;
				line-height: 20px;
				overflow: hidden;
				text-align: center;
				padding: 0 0;
				background: #ccc;
				color: #000;
				border: none;
			}
			#edit-panel button:active {
				background: #444;
				color: white;
			}
			
			.menu { 
				background: silver;
				color: black;
				position: fixed;
				z-index: 1000;
				list-style-type: none;
				padding: 0;
				margin: 0;
			}
			.menu li { 
				background: silver;
				color: black;
				padding: 10px;
				border: 1px outset grey;
				white-space: nowrap;
			}
			.menu li:hover { 
				background: #8cf;
				color: black;
				padding: 10px;
				border: 1px outset grey;
			}
			.menu > li > .menu { 
				display: none;
			}
			
			.menu > li:hover > .menu { 
				display: block;
			}
			
			.menu  .menu-label {
				line-height: 15px;
				display: inline-block;
			}
			
			.menu  .menu-icon {
				display: inline-block;
				overflow: visible;
				width: 30px;
				height: 30px;
				margin: -9px 10px -9px -9px;
				background-color: #888;
			}
		</style>
		
		<!-- 
			log.js : overwrites console.log and console.error to display messages within the wallpaper. 
		-->
		<script src="log.js"></script>
		
		<!-- 
			timer.js : simple timer class to measure performance 
		-->
		<script src="timer.js"></script>
		
		<!-- 
			audioarray.js : has a class that holds data for one channel ( left or right ) of the fft data with some
							useful functions to access it 
		-->
		<script src="audioarray.js"></script>
		
		<!-- 
			audiodata.js : has a class that holds 2 audiodata instances ( left/right channels ) with some useful
						   functions to access it 
		-->
		<script src="audiodata.js"></script>
		
		<!-- 
			audiocollection.js : is currently unused, i have used this to bunch up and average multiple fft data 
								 frames that might occur within one render frame when rendering at a low FPS 
		-->
		<script src="audiocollection.js"></script>
		
		<!--
			 audiodata-polyfill.js : fakes wallpaperRegisterAudioListener function for testing in the browser 
			 						 ( also see the guide as thre is another better alternative to this if needed ) 
		-->
		<script src="audiodata-polyfill.js"></script>
		
		<!-- 
			utils.js : contains some functions for processing the properties as well as a function to render 
					  the data in an audioframe object
		 -->
		<script src="utils.js"></script>
		
		<!-- 
			audioframe.js : somewhat misnamed class written to contain all the audio processing demonstrated 
							with configurable options 
		-->
		<script src="audioframe.js"></script>
		
		<script src="generators.js"></script>
		
		<script src="delayed.js"></script>
		
		<script src="flatten.js"></script>
		
		
		<script src="background.js"></script>		
		<link href="background-anim.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<div id="background-wrapper">
			<div id="background-image1-wrapper"><div id="background-image1"></div></div>
			<div id="background-image2-wrapper"><div id="background-image2"></div></div>
		</div>
		<canvas id="canvasBg"></canvas>
		<canvas id="canvas"></canvas>
		<div id="cpu-warning">
			<h2>CPU Usage Warning!</h2>
			<p>
				The CPU usage of this wallpaper is fairly high at the moment. Lower some settings. 
				<br>
				This might be caused by: 
				<small>
					Render method that is set to fill with large objects. <br>
					High detail level<br>
					Possibly glow effect.
				</small>
				<br>
				<br>
				Estimated CPU usage: <span id="usage-label"></span>
			</p>
		</div>
		<div id="edit-panel">
			<table>
				<tr>
					<td>
						<button id="close" style=" background: red; border: none; font-weight: bold;">&times;</button>
					</td>
				</tr>
				<tr>
					<td>Move:</td>
					<td>
						<button id="move-up">&#x25B2;</button>
						<button id="move-down">&#x25BC;</button>
						<button id="move-left">&#x25C4;</button>
						<button id="move-right">&#x25BA;</button>
					</td>
				</tr>
				<tr>
					<td>Rotate:</td>
					<td>
						<button id="rotate-up">&#x25B2;</button>
						<button id="rotate-down">&#x25BC;</button>
					</td>
				</tr>
				<tr>
					<td>Scale:</td>
					<td>
						<button id="scale-up">&#x25B2;</button>
						<button id="scale-down">&#x25BC;</button>
					</td>
				</tr>
				<tr>
					<td>&nbsp;</td>
					<td>&nbsp;</td>
				</tr>
				<tr>
					<td>Delete:</td>
					<td>
						<button id="delete">&times;</button>
					</td>
				</tr>
			</table>
		</div>
		<div id="svg-panel">
			<table>
				<tr>
					<td>
						<button id="svg-close" style="float: right; background: red; border: none; font-weight: bold;">&times;</button>
						<strong>Import SVG File</strong>
						<br>
						<small><strong>See the discussion on workshop page for more info on how to use.</strong></small>
						<br>
						<br>
						<small>Importing can be heavy on the cpu and take a while to process.</small>
					</td>
				</tr>
				<tr>
					<td>
						<input id="svg-file" type="file" accept=".svg" />
						<div id="svg-progress-wrapper">
							<div id="svg-progress"></div>
						</div>
					</td>
				</tr>
			</table>
		</div>
		<div id="fps"></div>
		
		<!-- all main scripting -->
		<script>
			// hide log & timer
			log.hide();
			timer.hide();
			
			// define global variables
			var canvas = null;
			var context = null;
			var canvasBg = null;
			var contextBg = null;
			
			// variables regarding use fps settings & frameskipping
			var targetFramerate = 30; // wallpaper engine will supply us with the target framerate and we will use a sloppy frameskipping mechanism to adjust to that.
			var targetFramerateUser = 0; // used to override wallpaper engines settings with wallpaper settings .. when value is 0 targetFramerate is used
			var nextRenderTimestamp = 0; // used from frameskipping to determine if current time is before or after we should render the next frame (see render function)
			
			// variable regarding fps
			var fpsElement = null;
			var fpsPrevUpdate = 0;
			var fpsFrameCount = 0;
			var fpsRenderTime = 0;
			
			var cpuWarningVisible = false;
			var cpuWarningElement = null;//cpu-warning
			var cpuWarningLabel = null;//usage-label
			
			var cpuCores = 4;
			var cpuWarningAt = 10;
			
			// screen width & height ( maintained via onResize event )
			var width, height;
			
			// render function to use
			var renderFunction = 'default';
			
			//var bgColor = 'black';
			//v//ar bgImage = '';
			//var bgTintElement = null;
			//var backgroundTint = 0;
			//var backgroundBlur = 0;
			
			var cfgHeightCutoff = 0;
			var heightCutoff = 0;
			var heightDir = 3;
			
			var offsetX = 0;
			var offsetY = 0;
			var baseRotation = 0;
			
			
			/*
				! audioFrame found in utils.js
				
				in audioFrame is where I store the audio data and do all processing of the incoming audio listener event
				Most code regarding the wallpaper settings are found in there.
			*/
			var frame2; // is an AudioFrame object .. stores the "processes" data and is created in setup()
			var frameHistory = [];
			
			var cfgRadiusFactor = 1;
			var radiusFactor = 1;
			var freqScaleAdjustment = 1;
			var freqScaleAdjustmentAnim = true;
			
			var initialized = false;
			var lastEqChange = -1000000000000;
			
			var useOutline = true;
			var interpolationSteps = 1;
			var interpolationBalanced = true;
			var renderMethod = 1;
			var animateWhenSilent = true;
			var animateWhenSilentHeight = 0.01;
			
			var userShape = new shapePointList();
			var additionalShapes = [];
			var defaultShapes = {
				'circle': shapeCircle,
				'heart': shapeHeart,
				'cannabis': shapeLeaf,
				'butterfly': shapeButterfly,
				'pointlist': shapePointList
			}
			var defaultGenerators = {
				'hazard': generatorBiohazard,
				'pokeball': generatorPokeball,
				'swirl': generatorSwirl,
				'swirl2': generatorSwirlReversed,
				'swirl3': generatorSwirl2,
				'swirl4': generatorSwirl2Reversed,
				'swirl5': generatorSwirl3,
				'swirl6': generatorSwirl3Reversed,
				'swirl7': generatorSwirl4,
				'swirl8': generatorSwirl4Reversed,
				'circlePattern1': generatorLeaf6,
				'circlePattern2': generatorLeaf8,
				'circlePattern3': generatorLeaf26,
				'circlePattern4': generatorLeaf36,
				'circlePattern5': generatorLeaf28,
				'circlePattern6': generatorSwirl3BiDirectional,
				'circlePattern7': generatorSwirl4BiDirectional,
				'cross': generatorCross,
				'cross2': generatorCross2,
				'plus': generatorPlus,
				'h-line': generatorHLine,
				'v-line': generatorVLine,
				'h-line2': generatorH2Line,
				'v-line2': generatorV2Line,
				'h-line3': generatorH3Line,
				'v-line3': generatorV3Line,
				'diamond': generatorDiamond,
				'square': generatorSquare,
				'peace': generatorPeace,
				'pentagram': generatorPentagram,
				'yinyang': generatorYinYang,
				'atom': generatorAtom
			}
			
			var shapeList = new ShapeList();
			var gen = new generatorSwirlReversed();
			gen.generate( shapeList );
			
			var hadAudioFrame = false;
			var isPaused = false;
			var allowDrawing = false;
			var lockedDrawing = false;
			
			var bg;
			var bgSettingsProxy;
			var fnInitSlideshow;
							
			var color1 = [0, 1, 0.5];
			var color2 = [0.333333, 1, 0.5];
			var color3 = [0.666666, 1, 0.5];
			var colorGradient = 2;
			var colorRotation = true;
			var colorGlow = 0;
			var colorGlowStrength = 2;
			
			function listMenu( id, icon, label, parent )
			{
				this.id = id;
				this.x = 0;
				this.y = 0;
				
				this.onClick = null;
				this.visible = true;
				
				this.parentElement = parent || null;
				this.childElements = [];
				
				if( !parent ) {
					this.realRootElement = document.createElement( 'ul' );
					this.realRootElement.className = 'menu';
				}
				this.rootElement = document.createElement( 'li' );
				this.subElements = document.createElement( 'ul' );
				this.subElements.className = 'menu';
				this.labelElement = document.createElement( 'span' );
				this.labelElement.className = 'menu-label';
				this.iconElement = document.createElement( 'span' );
				this.iconElement.className = 'menu-icon';
				
				if( icon ) {
					this.iconElement.style.background = 'url("' + icon + '"),  #888';
					this.iconElement.style.backgroundPosition = 'center center';
					this.iconElement.style.backgroundRepeat = 'no-repeat';
				}
				if( label ) {
					this.labelElement.innerHTML = label;
				}
				if( !parent ) {
					this.rootElement.appendChild( this.iconElement );
					this.rootElement.appendChild( this.labelElement );
					this.rootElement.appendChild( this.subElements );
					this.realRootElement.appendChild( this.rootElement );
					document.body.appendChild( this.realRootElement );
				}
				else {
					this.rootElement.appendChild( this.iconElement );
					this.rootElement.appendChild( this.labelElement );
					this.rootElement.appendChild( this.subElements );
					document.body.appendChild( this.rootElement );
				}
				
				var self = this;
				this.rootElement.onmouseover = function(e) { self.mouseover(e); }
				this.rootElement.onmouseout = function(e) { self.mouseout(e); }
				this.rootElement.onclick = function(e) { if( self.onClick) self.onClick(e,self); }
				
				this.show = function() { this.rootElement.style.display = 'block'; this.visible = true; }
				this.hide = function(recurse) { 
					recurse = recurse || false;
					delayedMenuHide.cancel();
					this.rootElement.style.display = 'none'; 
					if( recurse ) {
						for( var i = 0; i < this.childElements.length; i++ ) {
							this.childElements[i].hide(recurse);	
						}
					}
					this.visible = false;
				}
				
				this.hideChildrenOfChildren = function() 
				{
					for( var i = 0; i < this.childElements.length; i++ ) {
						var c = this.childElements[i];		
						for( var j = 0; j < c.childElements.length; j++ ) {
							c.childElements[j].hide();	
						}
					}
				}
				this.position = function(x,y) { 
					this.x = x; 
					this.y = y; 
					if( this.realRootElement ) {
						this.realRootElement.style.left = (x) + 'px'; 
						this.realRootElement.style.top = (y) + 'px';
					}
				}
				
				this.prependChild = function( id, icon, label )
				{
					var el = new listMenu( id, icon, label, this );
					this.childElements.unshift( el );
					this.subElements.insertBefore( el.rootElement, this.subElements.childNodes[ 0 ] );
					return el;
				}
				
				this.addChild = function( id, icon, label )
				{
					var el = new listMenu( id, icon, label, this );
					this.childElements.push( el );
					this.subElements.appendChild( el.rootElement );
					return el;
				}
				
				this.removeChild = function(id, recurse)
				{
					recurse = recurse || false;
					
					for( var i = 0; i < this.childElements.length; i++ )
					{
						if( recurse ) {
							this.childElements[ i ].removeChild( id, true );
						}
						if( this.childElements[ i ].id == id ) {
							this.subElements.removeChild( this.childElements[ i ].rootElement );
							this.childElements.splice(i,1);
							i--;
						}
					}
				}
				
				this.mouseover = function(e)
				{
					e.preventDefault();
					e.stopPropagation();
					for( var i = 0; i < this.childElements.length; i++ )
					{
						 this.childElements[ i ].show();
						
					}
					var self = this;
					setTimeout( function(){
						var px = self.x + self.rootElement.offsetWidth;
						var py = self.y + self.rootElement.offsetTop;
						if( px + self.subElements.offsetWidth > width ) {
							px = self.x - self.subElements.offsetWidth;
						}
						if( py + self.subElements.offsetHeight > height ) {
							py = self.y + self.rootElement.offsetTop - self.subElements.offsetHeight + self.rootElement.offsetHeight;
						}
						for( var i = 0; i < self.childElements.length; i++ )
						{
							 self.childElements[ i ].position( px, py ) ;
							 self.childElements[ i ].show();
							
						}
						
						self.subElements.style.left = px + 'px';
						self.subElements.style.top = py + 'px';
					}, 10 );
					//this.subElements.style.display = 'block';
					delayedMenuHide.trigger();
				}
				
				this.posOnScreen = function( x, y )
				{
					return ( x >= 300 && y >= 300 && x < width-300 && y < height-300  )	
				}
				
				this.mouseout = function()
				{
					//this.subElements.style.display = 'none';
				}
			}
			
			function radialMenu( id, icon, label, parent )
			{
				this.id = id;
				this.x = 0;
				this.y = 0;
				this.px = 0;
				this.py = 0;
				this.prad = null;
				
				this.pdeg = 0;
				this.pminDeg = 0;
				this.pmaxDeg = 360;
				
				this.onClick = null;
				this.visible = false;
				
				this.parentElement = parent || null;
				this.childElements = [];
				
				this.rootElement = document.createElement( 'DIV' );
				this.rootElement.className = 'radial-menu ' + ( this.parentElement ? 'radial-menu-item' : 'radial-menu-root' );
				if( icon ) {
					this.rootElement.style.backgroundImage = 'url( ' + icon + ' )';
					this.rootElement.style.backgroundPosition = 'center center';
					this.rootElement.style.backgroundRepeat = 'no-repeat';
				}
				else if( label ) {
					this.rootElement.innerHTML = label;
				}
				
				//if( this.parentElement ) {
				//	this.parentElement.rootElement.appendChild( this.rootElement );
				//}
				//else {
					document.body.appendChild( this.rootElement );
				//}
				
				var self = this;
				this.rootElement.onmouseover = function(e) { self.mouseover(e); }
				this.rootElement.onmouseout = function(e) { self.mouseout(e); }
				this.rootElement.onclick = function(e) { if( self.onClick) self.onClick(e,self); }
				
				this.show = function() { this.rootElement.style.display = 'block'; this.visible = true; }
				this.hide = function(recurse) { 
					recurse = recurse || false;
					this.rootElement.style.display = 'none'; 
					this.rootElement.style.backgroundColor = '#404040';
					if( recurse ) {
						for( var i = 0; i < this.childElements.length; i++ ) {
							this.childElements[i].hide(recurse);	
						}
					}
					this.visible = false;
				}
				
				this.hideChildrenOfChildren = function() 
				{
					for( var i = 0; i < this.childElements.length; i++ ) {
						var c = this.childElements[i];		
						for( var j = 0; j < c.childElements.length; j++ ) {
							c.childElements[j].hide();	
						}
					}
				}
				this.position = function(x,y) { 
					this.x = x; 
					this.y = y; 
					this.rootElement.style.left = (x-25) + 'px'; 
					this.rootElement.style.top = (y-25) + 'px';
				}
				
				this.parentPosition = function(px,py,rad, deg, minDeg, maxDeg) { 
					this.px = px; 
					this.py = py; 
					this.prad = rad; 
					this.pdeg = (deg+1080) % 360; 
					this.pmaxDeg = (maxDeg+1080) % 360; 
					this.pminDeg = (minDeg+1080) % 360; 
					if( this.pminDeg >= this.pmaxDeg) { 
						this.pmaxDeg += 360;
					}
				}
				
				this.update = function()
				{
					if( this.visible && this.parentElement && this.parentElement.visible ) {
						this.doUpdate();
					}
					for( var i = 0; i < this.childElements.length; i++ ) {
						this.childElements[i].update();	
					}
				}
				
				this.doUpdate = function()
				{
					return;
					var dx = 0;
					var dy = 0;
					// calculate rotation force
					if( ( this.pdeg < this.pminDeg && this.pdeg > this.pmaxDeg-360 ) 
					   || this.pdeg > this.pmaxDeg )
					{
						var md1 = this.pminDeg % 360;
						var md2 = this.pmaxDeg % 360;
						while( md1 > this.pdeg ) md1 -= 360;
						while( md1 < this.pdeg ) md1 += 360;
						while( md2 < this.pdeg ) md2 += 360;
						while( md2 > this.pdeg ) md2 -= 360;
						
						var d1 = Math.abs( md1 - this.pdeg );
						var d2 = Math.abs( md2 - this.pdeg );
						
						//console.error( d1 + ' ' + d2 + ' ' + this.pdeg + ' ' + this.pminDeg + ' ' + this.pmaxDeg );
						if(  d1 < d2 ) {
							// increase deg
							dx += Math.cos( (this.pdeg - 90)*Math.PI/180 )*5;
							dy += Math.cos( (this.pdeg - 90)*Math.PI/180 )*5;
						}
						else {
							// decrease deg
							dx += Math.sin( (this.pdeg + 90)*Math.PI/180 )*5;
							dy += Math.cos( (this.pdeg + 90)*Math.PI/180 )*5;
						}
						
						this.x += dx;
						this.y += dy;
						this.position( this.x, this.y );
							
	   				    var rad = Math.atan2(this.x - this.px, this.y - this.py);
	   				    this.prad = rad + Math.PI;
	   				    this.pdeg = rad * 180 / Math.PI;
					}
   				    
				
   				    
					// calculate rotation force
					var l = Math.sqrt( Math.pow( this.x-this.px,2 ) + Math.pow( this.y-this.py,2 ) );
					var loffset = 75-l;
					dx = Math.sin( (this.pdeg )*Math.PI/180 )*loffset/10;
					dy = Math.cos( (this.pdeg )*Math.PI/180 )*loffset/10;
					this.x += dx;
					this.y += dy;
					this.position( this.x, this.y );
					
					return;
					
					// check for distance to parents parent
					if( this.parentElement )
					{
						if( this.parentElement.parentElement ) {
							var x = this.parentElement.parentElement.x;
							var y = this.parentElement.parentElement.y;
							var dx = this.x-x;
							var dy = this.y-y;
							var l = Math.sqrt( Math.pow( dx,2 ) + Math.pow( dy,2 ) );
							if( l < 52 ) {
								dx/=l;
								dy/=l;
								this.position( this.x + dx, this.y + dy );
							}
						}
						
						// move everything else out of the way if needed :D
						for( var i = 0; i < this.parentElement.childElements.length; i++ ) {
							var x = this.parentElement.childElements[i].x;
							var y = this.parentElement.childElements[i].y;
							var dx = this.x-x;
							var dy = this.y-y;
							var l = Math.sqrt( Math.pow( dx,2 ) + Math.pow( dy,2 ) );
							if( l < 52 ) {
								if( l > 0 ) {
									dx/=l;
									dy/=l;
								}
								this.parentElement.childElements[i].position( x - dx, y - dy );
								
							}
						}
					}
   				    
				}
				
				this.addChild = function( id, icon, label )
				{
					var el = new radialMenu( id, icon, label, this );
					this.childElements.push( el );
					return el;
				}
				
				this.removeChild = function(id, recurse)
				{
					recurse = recurse || false;
					
					for( var i = 0; i < this.childElements.length; i++ )
					{
						if( recurse ) {
							this.childElements[ i ].removeChild( id, true );
						}
						if( this.childElements[ i ].id == id ) {
							this.childElements.splice(i,1);
							i--;
						}
					}
				}
				
				this.mouseover = function(e)
				{
					if( !this.visible ) return;
					if(e) e.stopPropagation();
					
					this.rootElement.style.backgroundColor = '#406080';
					
					this.hideChildrenOfChildren();
					
					// hide children of parent ( leave parent in position )		
					if( this.parentElement ) {			
						for( var i = 0; i < this.parentElement.childElements.length; i++ ) {
							if( this.parentElement.childElements[i] != this ) {
								this.parentElement.childElements[i].hide();	
							}
							//this.childElements[i].position();	
						}
						if( this.parentElement.parentElement ) {
							this.parentElement.parentElement.hide();
						}
						this.parentElement.show();
						this.parentElement.rootElement.style.backgroundColor = '#203040';
					}
					
					var scanFrom = -1;
					if( !this.posOnScreen( this.x + 100, this.y ) ) {
						scanFrom = 90;
					}
					else if( !this.posOnScreen( this.x - 100, this.y ) ) {
						scanFrom = 270;
					}
					else if( !this.posOnScreen( this.x , this.y - 100 ) ) {
						scanFrom = 180;
					}
					else if( !this.posOnScreen( this.x, this.y + 100 ) ) {
						scanFrom = 0;
					}
					
					var minDeg = 0;
					var maxDeg = 360;
					if( scanFrom >= 0 ) {
						var firstFound = -1;
						var lastFound = -1;
						for( var i = scanFrom; i < scanFrom + 360; i++ )
						{
							var visi = this.posOnScreen( this.x + Math.sin( i * Math.PI / 180 ) * 100, this.y + Math.cos( i * Math.PI / 180 ) * 100 );
							if( firstFound == -1 && visi ) {
								firstFound = i;
							}
							if( firstFound != -1 ) {
								if( visi ) 
									lastFound = i;
								else 
									break;
							}
						}
						minDeg = firstFound;
						maxDeg = lastFound;
					}
					//var degTotal = maxDev - minDeg;
					//var visibleLen = 2 * Math.PI * 75 * degTotal / 360;
					
					
					// show own children
					var elemsToShow = this.childElements.length+( this.prad === null ? 0 : 1 );
					
					//var lenNeeded = elemsToShow * 50;
					//var radius = lenNeeded * 360 / degTotal / 2 / Math.PI;
					
					var rad, 
						radBase = this.prad !== null ? this.prad : Math.PI, 
						radOffsetFirst = this.prad !== null ? 1 * Math.PI * 2 / elemsToShow  : 0;
						
					for( var i = 0; i < this.childElements.length; i++ ) {
						this.childElements[i].show();	
						rad = radBase - radOffsetFirst - i * Math.PI * 2 / elemsToShow ;
						this.childElements[i].parentPosition( this.x , this.y, rad + Math.PI,  rad * 180 / Math.PI, minDeg, maxDeg );	
						this.childElements[i].position( this.x + Math.sin(rad)*75, this.y + Math.cos(rad)*75 );	
					}
					
					delayedMenuHide.trigger();
				}
				
				this.posOnScreen = function( x, y )
				{
					return ( x >= 300 && y >= 300 && x < width-300 && y < height-300  )	
				}
				
				this.mouseout = function()
				{
					this.rootElement.style.backgroundColor = '#404040';
					if( !this.visible ) return;
					
				}
			}
			
			function ShapeStorage()
			{
				this.loadShapeList = function( key, shapeList )
				{
					//console.log( location.hostname );
					shapeList.importJson( window.localStorage.getItem( key ) );
				}
				
				this.saveShapeList = function( key, shapeList )
				{
					//console.log( location.hostname );
					//console.log( 'save:' + key );
					var failed = false;
					var val1 = shapeList.exportJson();
					try {
						window.localStorage.setItem( key, val1 );
						var val2 = window.localStorage.getItem( key );
						if( val1 != val2 ) failed = true; // just double checking .. couldnt quickly find accurate docs
					}
					catch( ex )
					{
						failed = true;
					}
					if( failed ) {
						console.error( 'Failed to save' );
					}
					else {
						//console.error( 'saved: ' + val1.length );
					}
					return !failed;
				}
			}

			function EditPanel()
			{
				var self = this;
				this.shape = null;
				this.panel = document.getElementById('edit-panel');
				this.panel.addEventListener('mousedown', function(e) { e.preventDefault(); e.stopPropagation(); return false; }, false );
				this.panel.addEventListener('mouseup', function(e) { e.preventDefault(); e.stopPropagation(); return false;}, false );
				
				this.btnClose = document.getElementById('close');
				this.btnClose.addEventListener('mousedown', function(e) { e.preventDefault(); e.stopPropagation(); deselectShape(); return false; }, false );
				
				this.btnDelete = document.getElementById('delete');
				this.btnDelete.addEventListener('mousedown', function(e) {
					e.preventDefault(); e.stopPropagation();
					if( !self.shape ) return;
					self.shape.hasBeenRemoved = true;
					deselectShape(); 
				    return false;
				 }, false );
				
				this.btnMoveLeft = document.getElementById('move-left');
				this.btnMoveRight = document.getElementById('move-right');
				this.btnMoveUp = document.getElementById('move-up');
				this.btnMoveDown = document.getElementById('move-down');
				
				this.btnRotateUp = document.getElementById('rotate-up');
				this.btnRotateDown = document.getElementById('rotate-down');
				
				this.btnScaleUp = document.getElementById('scale-up');
				this.btnScaleDown = document.getElementById('scale-down');
				
				this.show = function() { this.panel.style.display = 'block';  lockedDrawing = true; }
				this.hide = function() { this.panel.style.display = 'none';  lockedDrawing = false; }
				
				
				this.move = function( x, y )
				{
					if( !this.shape ) return;
					// adjust all points by x,y
					this.shape.translate( x, y );
					shapeList.updateAutosave();
				}
				
				this.rotate = function( r )
				{
					if( !this.shape ) return;
					// adjust all points by x,y
					this.shape.rotate( r * Math.PI / 180 );
					shapeList.updateAutosave();
				}
				
				this.scale = function( s )
				{
					if( !this.shape ) return;
					// adjust all points by x,y
					this.shape.scale( s, s );
					shapeList.updateAutosave();
				}
				
				var self = this;
				holdit( this.btnMoveLeft, function() {self.move( -1, 0 );} , 300, 1.1 );
				holdit( this.btnMoveRight, function() {self.move( 1, 0 );} , 300, 1.1 );
				holdit( this.btnMoveUp, function() {self.move( 0, -1 );} , 300, 1.1 );
				holdit( this.btnMoveDown, function() {self.move( 0, 1 );} , 300, 1.1 );
				
				holdit( this.btnRotateUp, function() {self.rotate(-1);} , 300, 1.1 );
				holdit( this.btnRotateDown, function() {self.rotate(1);} , 300, 1.1 );
				
				holdit( this.btnScaleUp, function() {self.scale(1.01);} , 300, 1.1 );
				holdit( this.btnScaleDown, function() {self.scale(1/1.01);} , 300, 1.1 );
				
				
				function holdit(btn, action, start, speedup) {
				    var t;
					var originalStart = start;
				    var repeat = function () {
				        action();
				        t = setTimeout(repeat, start);
				        start = start / speedup;
				        if( start < 30 ) start = 30;
				    }

				    btn.addEventListener('mousedown',function(e) {
						e.stopPropagation();
						e.preventDefault();
						start = originalStart;
				        repeat();
				        return false;
				    },false);

				    btn.addEventListener('mouseup',function (e) {
						e.stopPropagation();
						e.preventDefault();
				        clearTimeout(t);
				        return false;
				    },false);

				    btn.addEventListener('mouseout',function (e) {
						e.stopPropagation();
						e.preventDefault();
				        clearTimeout(t);
				        return false;
				    },false);
				};
				
			}

			function SvgPanel()
			{
				var self = this;
				this.shape = null;
				this.panel = document.getElementById('svg-panel');
				this.panel.addEventListener('mousedown', function(e) { e.preventDefault(); e.stopPropagation(); return false;}, false );
				this.panel.addEventListener('mouseup', function(e) { e.preventDefault(); e.stopPropagation(); return false;}, false );
				
				this.progressWrapper = document.getElementById('svg-progress-wrapper');
				this.progressWrapper.style.display = 'none';
				this.progress = document.getElementById('svg-progress');
				
				this.btnClose = document.getElementById('svg-close');
				this.btnClose.addEventListener('mousedown', function(e) { e.preventDefault(); e.stopPropagation(); self.hide();  return false;}, false );
				this.btnClose.addEventListener('mouseup', function(e) { e.preventDefault(); e.stopPropagation();  return false; }, false );
				
				this.inpFile = document.getElementById('svg-file');
				this.inpFile.addEventListener('mousedown', function(e) { e.preventDefault(); e.stopPropagation(); return false;}, false );
				this.inpFile.addEventListener('mouseup', function(e) { e.preventDefault(); e.stopPropagation(); return false;}, false );
				this.inpFile.addEventListener('change', function(e) {
					e.preventDefault(); e.stopPropagation();
					self.progressWrapper.style.display = 'block';
					self.btnClose.style.display = 'none';
					self.progress.style.width = 0;
					try {
						var file = self.inpFile.files[0];
						if( file ) {
						  	var reader = new FileReader();

						  	reader.onload = function(e) {
								try {
									svgSource = new SvgSource( reader.result, 
																function(perc) {			
																	self.progress.style.width = Math.round( 100 * perc ) + "%";
																} , 
																function() {										
																	self.hide();
																	shapeList.updateAutosave();
																	self.progressWrapper.style.display = 'none';
																	self.btnClose.style.display = 'block';
																} );
								}
								catch( ex ){
									console.log( ex.message );
									self.progressWrapper.style.display = 'none';
									self.btnClose.style.display = 'block';
								}
						  	}

						  	reader.readAsText(file); 
						}
					}
					catch( ex ){
						self.progressWrapper.style.display = 'none';
						self.btnClose.style.display = 'block';
						console.log( ex.message );
					}
					
				 }, false );
				
				
				
				this.show = function() { this.panel.style.display = 'block'; self.btnClose.style.display = 'block'; self.progressWrapper.style.display = 'none'; self.progress.style.width = 0; lockedDrawing = true; this.inpFile.value = ""; }
				this.hide = function() { this.panel.style.display = 'none'; lockedDrawing = false;  }
			}
			
			var editPanel = new EditPanel();
			var svgPanel = new SvgPanel();
			
			var storage = new ShapeStorage();
			/*
			var menu2 = new listMenu( 'root', window.location.href.replace('index.html','') + 'icon_home.png', 'Menu');
			//menu2.position( window.innerWidth/2, window.innerHeight/2 );
			//menu2.show();
			var el1 = menu2.addChild( 'item1', null, 'clear' ); 
			//var el2 = menu.addChild( 'item2', null, 'load' );
			//var el3 = menu.addChild( 'item3', null, 'save' );
			var el4 = menu2.addChild( 'item4', null, 'close' );
			var el5 = menu2.addChild( 'item4', null, 'draw' );
			
			var elD11 = el5.addChild( 'item7', null, 'scribble' );
			var elD12 = el5.addChild( 'item8', null, 'line' );
			//var elD13 = elD1.addChild( 'item8', null, 'h line' );
			//var elD14 = elD1.addChild( 'item8', null, 'v line' );
			
			var elD21 = el5.addChild( 'item7', null, 'oval' );
			var elD22 = el5.addChild( 'item8', null, 'circle' );
			*/
			var baseRef = window.location.href.replace('index.html','');
			var menu = new listMenu( 'root', baseRef + 'icon_close.png', 'Close');
			menu.position( window.innerWidth/2, window.innerHeight/2 );
			
			var delayedMenuHide = new delayed( function() { hideMenu(); }, 5000 );
			
			//var el4 = menu.addChild( 'item4', null, 'close' );
			//var el2 = menu.addChild( 'item2', null, 'load' );
			//var el3 = menu.addChild( 'item3', null, 'save' );
			var el5 = menu.addChild( 'item4', baseRef + 'icon_scribble.png', 'Draw' );
			var el6 = menu.addChild( 'item4', baseRef + 'icon_import.png', 'Import' );
			var el1 = menu.addChild( 'item1', baseRef + 'icon_clear.png', 'Clear' );
			var el7 = menu.addChild( 'item7', baseRef + 'icon_disk.png', 'Storage' );
			
			//var elD1 = el5.addChild( 'item8', null, 'line' );
			//var elD2 = el5.addChild( 'item9', null, 'circle' );
			//var elD3 = el5.addChild( 'item10', null, 'square' );
			
			var el71 = el7.addChild( 'item7', baseRef + '.png', 'Slot 1' );
			var el72 = el7.addChild( 'item7', baseRef + '.png', 'Slot 2' );
			var el73 = el7.addChild( 'item7', baseRef + '.png', 'Slot 3' );
			
			var el712 = el71.addChild( 'item7', baseRef + 'icon_diskl.png', 'Load' );
			var el711 = el71.addChild( 'item7', baseRef + 'icon_disks.png', 'Save' );
			
			var el722 = el72.addChild( 'item7', baseRef + 'icon_diskl.png', 'Load' );
			var el721 = el72.addChild( 'item7', baseRef + 'icon_disks.png', 'Save' );
			
			var el732 = el73.addChild( 'item7', baseRef + 'icon_diskl.png', 'Load' );
			var el731 = el73.addChild( 'item7', baseRef + 'icon_disks.png', 'Save' );
			
			el712.onClick = function( e, el ) { storage.loadShapeList( 'as_slot1', shapeList ); shapeList.updateAutosave(); }
			el711.onClick = function( e, el ) { storage.saveShapeList( 'as_slot1', shapeList ); }
			
					
			el722.onClick = function( e, el ) { storage.loadShapeList( 'as_slot2', shapeList ); shapeList.updateAutosave(); }
			el721.onClick = function( e, el ) { storage.saveShapeList( 'as_slot2', shapeList ); }
			
			el732.onClick = function( e, el ) { storage.loadShapeList( 'as_slot3', shapeList ); shapeList.updateAutosave(); }
			el731.onClick = function( e, el ) { storage.saveShapeList( 'as_slot3', shapeList ); }
			
			var elD11 = el5.addChild( 'item7', baseRef + 'icon_scribble.png', 'Scribble' );
			var elD12 = el5.addChild( 'item8', baseRef + 'icon_line.png', 'Line' );
			//var elD13 = elD1.addChild( 'item8', null, 'h line' );
			//var elD14 = elD1.addChild( 'item8', null, 'v line' );
			
			var elD21 = el5.addChild( 'item7', baseRef + 'icon_oval.png', 'Oval' );
			var elD22 = el5.addChild( 'item8', baseRef + 'icon_circle.png', 'Circle' );
			
			var elD31 = el5.addChild( 'item7', baseRef + 'icon_rect.png', 'Rect' );
			var elD32 = el5.addChild( 'item8', baseRef + 'icon_square.png', 'Square' );
			
			el1.onClick = function( e, el ) {  hideMenu(); shapeList.empty(); }
			menu.onClick = function( e, el ) { hideMenu();  }
			el6.onClick = function( e, el ) { hideMenu(); svgPanel.show(); }
			
			elD11.onClick = function( e, el ) { drawController = new mouseDrawScribble(); hideMenu();}
			elD12.onClick = function( e, el ) { drawController = new mouseDrawLine(); hideMenu(); }
			
			elD21.onClick = function( e, el ) { drawController = new mouseDrawOval(); hideMenu();}
			elD22.onClick = function( e, el ) { drawController = new mouseDrawCircle(); hideMenu(); }
			
			elD31.onClick = function( e, el ) { drawController = new mouseDrawRect(); hideMenu();}
			elD32.onClick = function( e, el ) { drawController = new mouseDrawSquare(); hideMenu(); }
			
			hideMenu();
			                   
			   /*                                       
			el2.addChild( 'item1', null, 'select' );
			el2.addChild( 'item2', 'item2', 'item2' );
			el2.addChild( 'item3', 'item3', 'item3' );
			el2.addChild( 'item4', 'item4', 'item4' );
			el2.addChild( 'item5', 'item5', 'item5' );
			el2.addChild( 'item5', 'item5', 'item5' );
			     */                                     
			/**
			 * setup wallpaper stuff
			 **/
			function setup()
			{
				bg = new Background( 	document.body, 
										document.getElementById('background-image1' ), 
										document.getElementById('background-image2' ), 
										document.getElementById('background-image1-wrapper' ), 
										document.getElementById('background-image2-wrapper' ) );
										
				// delay initialisation until we got the first properties
				fnInitSlideshow = function() { 
					bg.play(true); 	 // start the slideshow loop
					fnInitSlideshow = null;	
				}
				
								
				// arguments are the background instance and assigning the property names
				// leave a property out if you dont use it or set it to null
				bgSettingsProxy = new BackgroundSettingsProxy( bg, {
					'image-file': 'backgroundImage', //  setting of type file
					'image-folder': 'slideshowFolder', //  setting of type directory
					'image-size': 'backgroundSize', // setting of type combo with options 'contain' | 'cover'
					'image-opacity': 'backgroundOpacity', //  setting of type slider/combo with values 0 - 100 
					
					'slideshow-use-transitions': 'slideshowUseTransitions', // setting of type bool/combo with true/false ( numeric values 0 and 1 should work too )
					'slideshow-transition-duration': 'slideshowTransitionDuration', // setting of type slider/combo with values 0 to 3600 ( 1 hour )
					'slideshow-interval': 'slideshowInterval', // setting of type slider/combo with int values
					'slideshow-interval-multiply': 'slideshowIntervalMultiplier', // setting of type slider/combo with int values
					
					'color-1': 'backgroundColor', //  setting of type color ( or combo if you set values to color notation, aka '1 0 0' for red )

					'slideshow-transition-fade': 'slideshowTransFade',
					'slideshow-transition-fade-in': 'slideshowTransFadeIn',
					'slideshow-transition-fade-out': 'slideshowTransFadeOut',
					'slideshow-transition-zoom-in': 'slideshowTransZoomIn',
					'slideshow-transition-zoom-out': 'slideshowTransZoomOut',
					'slideshow-transition-zoom-horz-in': 'slideshowTransZoomHorzIn',
					'slideshow-transition-zoom-horz-out': 'slideshowTransZoomHorzOut',
					'slideshow-transition-zoom-vert-in': 'slideshowTransZoomVertIn',
					'slideshow-transition-zoom-vert-out': 'slideshowTransZoomVertOut',
					'slideshow-transition-move-left': 'slideshowTransMoveLeft',
					'slideshow-transition-move-right': 'slideshowTransMoveRight',
					'slideshow-transition-move-top': 'slideshowTransMoveTop',
					'slideshow-transition-move-bottom': 'slideshowTransMoveBottom',
					'slideshow-transition-shuffle-left': 'slideshowTransShuffleLeft',
					'slideshow-transition-shuffle-right': 'slideshowTransShuffleRight',
					'slideshow-transition-shuffle-top': 'slideshowTransShuffleTop',
					'slideshow-transition-shuffle-bottom': 'slideshowTransShuffleBottom'
				
				});
						
				fpsElement = document.getElementById('fps');
				fpsElement.style.display = 'block';
				
				//bgTintElement = document.getElementById('tint'); 
				
				canvas = document.getElementById('canvas'); // reference to our canvas element
				context = canvas.getContext('2d');  // reference to our context
				
				canvasBg = document.getElementById('canvasBg'); // reference to our canvas element
				contextBg = canvasBg.getContext('2d');  // reference to our context
			
				cpuWarningElement = document.getElementById('cpu-warning');
				cpuWarningLabel = document.getElementById('usage-label'); 
				
								
				// create container to store processed data
				frame2 = new AudioFrame({
					normalize: true,
					normalizeFactor: 0,
					motionBlur: true,
					motionBlurFactor: 1,
					smooth: true,
					smoothFactor: 0.75,
					powerOf: 4,
					mono: true
				});
				/*
				for( var i = 0; i < 64; i++ )
				{
					var f = frame2.idxToFreq( i );
					var j = frame2.freqToIdx( f );
					console.log( i + ':' + j + ' -> ' + f )
				}*/
			}
			
			/**
			 * processing anything regarding frameskipping
			 *
			 * @returns true when should skip
			 **/
			function shouldSkipFrame( timestamp )
			{
				// should we skip this frame?
				
				if( timestamp < nextRenderTimestamp ) {
					return true;
				}
				
				// update time for next frame to render
				var frameInterval = targetFramerateUser > 0 
									? 1000 / targetFramerateUser
									: 1000 / targetFramerate;		
				nextRenderTimestamp = Math.floor( timestamp / frameInterval ) * frameInterval + frameInterval;
				return false;
				
			}
			
			/**
			 * measures framerate & updates framerate label
			 **/
			function updateFps( timestamp )
			{ 
				if( timestamp > fpsPrevUpdate + 1000 )
				{
					var diff = ( timestamp - fpsPrevUpdate ) / 1000; // time diff in seconds
					var fps = fpsFrameCount / diff; // adjust framerate to exactly 1 second 
					
					
					var cpuUsage = fpsRenderTime/10/cpuCores + 2;
					cpuUsage *= 1.3;
					if( cpuUsage > 99 ) cpuUsage = 99;
					
					//fpsElement.innerText = true // simple way of hiding fps
					//						? fps.toFixed(1) + ' FPS / '  + ( cpuUsage ).toFixed(1) + '% ' + fpsRenderTime
					//						: '';
					
					
					if( cpuWarningAt < cpuUsage && !cpuWarningVisible )
					{
						cpuWarningVisible = true;
						cpuWarningElement.style.display = 'block';
						cpuWarningLabel.innerText = ( cpuUsage ).toFixed(0) + '%';
					}
					else if( cpuWarningAt > cpuUsage && cpuWarningVisible )
					{
						cpuWarningVisible = false;
						cpuWarningElement.style.display = 'none';
					}
					else if( cpuWarningVisible ) {
						cpuWarningLabel.innerText = ( cpuUsage ).toFixed(0) + '%';
					}
					fpsFrameCount = 0;
					fpsPrevUpdate = timestamp;
					fpsRenderTime = 0;
					
					
				}
				fpsFrameCount++;
			}
			
			var h = 0;
			var prevTimestamp;
			var timeDiff;
			var frameCount = 0;
			/**
			 * render wallpaper
			 **/
			function render( timestamp ) // requestAnimationFrame supplies its own timestamp. no need for performance.now();
			{					
				frameCount++;
				var t0 = performance.now();
				timestamp = timestamp || performance.now();
				if( timestamp > 2000 ) initialized = true;
				
				// queue next frame            
				//window.requestAnimationFrame( render );
				
				// frame skipping to maintain user selected framerate
				if( isPaused || !hadAudioFrame || shouldSkipFrame( timestamp ) ){
					setTimeout( render, isPaused ? 1000 : 8.33 );
					return;
				} 			
				
				hadAudioFrame = false;		
				
				
				timeDiff = timestamp - prevTimestamp;
				prevTimestamp = timestamp;
				
				updateFps( timestamp );
				 
				// menu.update();
				//
				// now on to actual render some stuff				
				//
				try {
					timer.start('render');
					
					// render a black background
					//context.fillStyle = 'rgb( 0, 0, 0 )';
					//context.fillRect( 0, 0, width, height );
					context.globalCompositeOperation = 'destination-out';
					context.fillStyle = 'rgba(0,0,0,0.6)';
					context.fillRect(0, 0, this.width, this.height);	
					context.globalCompositeOperation = 'source-over';
					
					// renderAudioFrame() can found in utils.js
					
					context.save();
					context.translate( offsetX, offsetY );
				  	context.translate(width/2, height/2);	
					context.rotate( baseRotation * Math.PI / 180 );
					context.translate(-width/2, -height/2);
			
					var v = colorRotation 
								? ( 360 * 1/6  ) + ( ++h/1 % 360 )
								: 0;
					var col1 = 'hsla(  ' + (color1[0]*360+v) + ', ' + Math.round( color1[1]*100) + '%, ' + Math.round( color1[2]*100) + '%, '+ 1 +' )';
					var col2 = 'hsla(  ' + (color2[0]*360+v) + ', ' + Math.round( color2[1]*100) + '%, ' + Math.round( color2[2]*100) + '%, '+ 1 +' )';
					var col3 = 'hsla(  ' + (color3[0]*360+v) + ', ' + Math.round( color3[1]*100) + '%, ' + Math.round( color3[2]*100) + '%, '+ 1 +' )';
					
					var gradient;
					switch( colorGradient ) {
						case 0: 
							gradient = col1;
							break;
						case 1:
							gradient = context.createRadialGradient(width/2, height/2, 0, width/2, height/2, (width+height)/4);
							gradient.addColorStop(0, col1);
							gradient.addColorStop(0.5, col2);
							gradient.addColorStop(1, col3);
							break;
						case 2:
							gradient = context.createLinearGradient(0, height/2, width, height/2 );
							gradient.addColorStop(0, col1);
							gradient.addColorStop(0.5, col2);
							gradient.addColorStop(1, col3);
							break;
						case 3:
							gradient = context.createLinearGradient(width/2, 0, width/2, height );
							gradient.addColorStop(0, col1);
							gradient.addColorStop(0.5, col2);
							gradient.addColorStop(1, col3);
							break;
					} 


					shapeList.render( context, gradient, interpolationSteps, interpolationBalanced, renderMethod );
					
					context.restore();
					
					var mousePath = drawController.points;
					if( mousePath.length > 1 ) {
						
						context.beginPath();
						context.strokeStyle = gradient;
						context.lineWidth = 1;
						//context.strokeStyle = 'rgba( 255, 255, 255, 0.5 )';
						context.moveTo( mousePath[0].x, mousePath[0].y );
						for( var i = 1; i < mousePath.length; i++ )
						{                
							var x = mousePath[i].x;
							var y = mousePath[i].y;
							context.lineTo(x, y );
						}
						context.stroke();
					}
					
					/** /
					context.beginPath();
					context.lineWidth = 0.5;
					context.strokeStyle = 'rgba( 255, 255, 255, 0.5 )';
					context.moveTo( width/2, 0 );
					context.lineTo( width/2+1, height );
					context.stroke();
					
					context.beginPath();
					context.lineWidth = 0.5;
					context.strokeStyle = 'rgba( 255, 255, 255, 0.5 )';
					context.moveTo( 0, height/2 );
					context.lineTo( width, height/2 );
					context.stroke();
					
					context.beginPath();
					context.lineWidth = 0.5;
					context.strokeStyle = 'rgba( 255, 255, 255, 0.5 )';
					context.arc( width/2, height/2, 200, 0, Math.PI*2);
					context.stroke();
					
					/**/
					
					/** /
					var f = new AudioFrame();
					f.audioDataResult.copyFrom( frame2.audioDataResult );
					f.config.downSample = frame2.config.downSample;
					frameHistory.unshift( f );
					for( var i = frameHistory.length-1; i >= 0 ; i-- ) {
						frameHistory[i].audioDataResult.multiply( 0.90 );
						frameHistory[i].audioDataResult.smooth( 0.5, -1 );
						//frameHistory[i].audioDataResult.smooth( 0.25 );
					}
					if( frameHistory.length > 0 ) {
						frameHistory.pop();
					}
					/**/
					
					
					//contextBg.fillStyle = 'black';
					//contextBg.fillRect( 0, 0, this.width, this.height );
					
					if( colorGlow > 0 ) {
						contextBg.globalCompositeOperation = 'destination-out';
						contextBg.fillStyle = 'rgba(0,0,0,1)';
						contextBg.fillRect(0, 0, this.width, this.height);	
						contextBg.globalCompositeOperation = 'source-over';
						
						contextBg.globalCompositeOperation = 'source-over';
						if( colorGlowStrength == 3 ) contextBg.drawImage( canvas, -1, -1 );
						if( colorGlowStrength == 3 ) contextBg.drawImage( canvas, 0, -1 );
						if( colorGlowStrength == 3 ) contextBg.drawImage( canvas, 1, -1 );
						if( colorGlowStrength == 2 ) contextBg.drawImage( canvas, -1, 0 );
						if( colorGlowStrength == 1 ) contextBg.drawImage( canvas, 0, 0 );
						if( colorGlowStrength == 2 ) contextBg.drawImage( canvas, 1, 0 );
						if( colorGlowStrength == 3 ) contextBg.drawImage( canvas, -1, 1 );
						if( colorGlowStrength == 3 ) contextBg.drawImage( canvas, 0, 1 );
						if( colorGlowStrength == 3 ) contextBg.drawImage( canvas, 1, 1 );
					}
					
					if( lastEqChange + 5000 > timestamp  ) {
						frame2.renderEQ( context );
					}
					timer.stop('render');
				}
				catch( ex )
				{
					var caller_line = ex.stack.split("\n");
					caller_line = caller_line[1];
					var index = caller_line.indexOf("at ");
					var clean = caller_line.slice(index+2, caller_line.length);
					
								
					console.error( clean.replace( /^\s+/g, '' ).replace( /(http|file).+\//g, '' )  + ' ' + ex.message );
				}
				var t1 = performance.now();
				fpsRenderTime += t1 - t0;
				setTimeout( render, isPaused ? 1000 : 8.33 );
			}
			
			var hasInit = false; // initialisation is simply triggered by first audioData event
			function onInit()
			{
				storage.loadShapeList( 'as_autosave', shapeList );
				if( svgSource )
				{
					svgSource.toShapeList( shapeList );
				}
			}
			
			/**
			 * called on window/screen resize
			 **/
			function onResize() {
				// update width/height
				width = canvas.width = window.innerWidth;
				height = canvas.height = window.innerHeight;
				width = canvasBg.width = window.innerWidth;
				height = canvasBg.height = window.innerHeight;
			}
			
			function mouseDrawSquare()
			{
				this.smooth = false;
				this.cx = 0;
				this.cy = 0;
				
				this.x = 0;
				this.y = 0;
				
				this.points = [];
				this.empty = function() { this.points = []; }
				
				this.updatePoints = function( detail )
				{
					var dx = this.x - this.cx;
					var dy = this.y - this.cy;
					var r = ( Math.abs(dx) + Math.abs(dy) ) / 2;
					dx = dx / Math.abs( dx );
					dy = dy / Math.abs( dy );
					
					//var r = Math.sqrt( dx*dx + dy*dy );
					
					this.points = [];
					this.points.push( { x: this.cx+r*dx/2, y: this.cy+r*dy, d: true } );
					this.points.push( { x: this.cx+r*dx, y: this.cy+r*dy,   d: true } );
					this.points.push( { x: this.cx+r*dx, y: this.cy, 	  d: true } );
					this.points.push( { x: this.cx, 	 y: this.cy, 	  d: true } );
					this.points.push( { x: this.cx, 	 y: this.cy+r*dy, d: true } );
					this.points.push( { x: this.cx+r*dx/2, y: this.cy+r*dy, d: true } );
				}
				
				this.mouseMove = function( x, y, isDown )
				{
					if( isDown ) {
						this.x = x;
						this.y = y;
						this.updatePoints( 60 );
					}
					return this.points;
				}
				this.mouseDown = function( x, y )
				{
					this.points = [];
					this.cx = this.x = x;
					this.cy = this.y = y;
					return this.points;
				}
				this.mouseUp = function( x, y )
				{
					this.x = x;
					this.y = y;
					this.updatePoints( 1080 );
					return this.points;
				}
			}
			
			function mouseDrawRect()
			{
				this.smooth = false;
				this.cx = 0;
				this.cy = 0;
				
				this.x = 0;
				this.y = 0;
				
				this.points = [];
				this.empty = function() { this.points = []; }
				
				this.updatePoints = function( detail )
				{
					var dx = this.x - this.cx;
					var dy = this.y - this.cy;
					var r = ( dx + dy ) / 2;
					//var r = Math.sqrt( dx*dx + dy*dy );
					
					this.points = [];
					this.points.push( { x: this.cx+dx/2, y: this.cy+dy, d: true } );
					this.points.push( { x: this.cx+dx, y: this.cy+dy, d: true } );
					this.points.push( { x: this.cx+dx, y: this.cy, d: true } );
					this.points.push( { x: this.cx, y: this.cy, d: true } );
					this.points.push( { x: this.cx, y: this.cy+dy, d: true } );
					this.points.push( { x: this.cx+dx/2, y: this.cy+dy, d: true } );
					/*
					this.points.push( { x: this.cx+dx/2, y: this.cy+dy, d: true } );
					this.points.push( { x: this.cx+dx, y: this.cy+dy, d: true } );
					this.points.push( { x: this.cx+dx, y: this.cy, d: true } );
					this.points.push( { x: this.cx, y: this.cy, d: true } );
					this.points.push( { x: this.cx, y: this.cy+dy, d: true } );
					this.points.push( { x: this.cx+dx/2, y: this.cy+dy, d: true } );
					*/
				}
				
				this.mouseMove = function( x, y, isDown )
				{
					if( isDown ) {
						this.x = x;
						this.y = y;
						this.updatePoints( 60 );
					}
					return this.points;
				}
				this.mouseDown = function( x, y )
				{
					this.points = [];
					this.cx = this.x = x;
					this.cy = this.y = y;
					return this.points;
				}
				this.mouseUp = function( x, y )
				{
					this.x = x;
					this.y = y;
					this.updatePoints( 1080 );
					return this.points;
				}
			}
			
			function mouseDrawCircle()
			{
				this.smooth = false;
				this.cx = 0;
				this.cy = 0;
				
				this.x = 0;
				this.y = 0;
				
				this.points = [];
				this.empty = function() { this.points = []; }
				
				this.updatePoints = function( detail )
				{
					var dx = this.x - this.cx;
					var dy = this.y - this.cy;
					var r = Math.sqrt( dx*dx + dy*dy );
					
					var radBase = Math.atan2( dx, dy );
					this.points = [];
					for( var i = 0; i <= detail; i++ )
					{
						var rad = Math.PI*2 * i / detail;
						this.points.push( { x: Math.sin(rad+radBase)*r+this.cx, y: Math.cos(rad+radBase)*r + this.cy, d: true } );
					}
				}
				
				this.mouseMove = function( x, y, isDown )
				{
					if( isDown ) {
						this.x = x;
						this.y = y;
						this.updatePoints( 60 );
					}
					return this.points;
				}
				this.mouseDown = function( x, y )
				{
					this.points = [];
					this.cx = this.x = x;
					this.cy = this.y = y;
					return this.points;
				}
				this.mouseUp = function( x, y )
				{
					this.x = x;
					this.y = y;
					this.updatePoints( 1080 );
					return this.points;
				}
			}
			
			function mouseDrawOval()
			{
				this.smooth = false;
				this.cx = 0;
				this.cy = 0;
				
				this.x = 0;
				this.y = 0;
				
				this.points = [];
				this.empty = function() { this.points = []; }
				
				this.updatePoints = function( detail )
				{
					var dx = this.x - this.cx;
					var dy = this.y - this.cy;
					var rx = Math.abs( dx );
					var ry = Math.abs( dy );
					
					
					var radBase = Math.atan2( 0, dy );
					
					this.points = [];
					for( var i = 0; i <= detail; i++ )
					{
						var rad = Math.PI*2 * i / detail;
						this.points.push( { x: Math.sin(rad+radBase)*rx+this.cx, y: Math.cos(rad+radBase)*ry + this.cy, d: true } );
					}
				}
				
				this.mouseMove = function( x, y, isDown )
				{
					if( isDown ) {
						this.x = x;
						this.y = y;
						this.updatePoints( 60 );
					}
					return this.points;
				}
				this.mouseDown = function( x, y )
				{
					this.points = [];
					this.cx = this.x = x;
					this.cy = this.y = y;
					return this.points;
				}
				this.mouseUp = function( x, y )
				{
					this.x = x;
					this.y = y;
					this.updatePoints( 1080 );
					return this.points;
				}
			}
			/*
			function mouseDrawSquare()
			{
				this.smooth = false;
				this.sx = 0;
				this.sy = 0;
				
				this.x = 0;
				this.y = 0;
				
				this.points = [];
				this.empty = function() { this.points = []; }
				
				this.updatePoints = function( detail )
				{
					var dx = this.x - this.sx;
					var dy = this.y - this.sy;
					
					
					var dt1 = [  { x: this.cx, y: this.cy, d: true },
								 { x: this.cx, y: this.cy, d: true }]
					this.points = [];
					for( var i = 0; i <= detail; i++ )
					{
						var rad = Math.PI*2 * i / detail;
						this.points.push( { x: Math.sin(rad)*r+this.cx, y: Math.cos(rad)*r + this.cy, d: true } );
					}
				}
				
				this.mouseMove = function( x, y, isDown )
				{
					if( isDown ) {
						this.x = x;
						this.y = y;
						this.updatePoints( 60 );
					}
					return this.points;
				}
				this.mouseDown = function( x, y )
				{
					this.points = [];
					this.sx = this.x = x;
					this.sy = this.y = y;
					return this.points;
				}
				this.mouseUp = function( x, y )
				{
					this.x = x;
					this.y = y;
					this.updatePoints( 1080 );
					return this.points;
				}
			}
			
			function mouseDrawRect()
			{
				this.smooth = false;
				this.cx = 0;
				this.cy = 0;
				
				this.x = 0;
				this.y = 0;
				
				this.points = [];
				this.empty = function() { this.points = []; }
				
				this.updatePoints = function( detail )
				{
					var dx = this.x - this.cx;
					var dy = this.y - this.cy;
					var rx = Math.abs( dx );
					var ry = Math.abs( dy );
					
					this.points = [];
					for( var i = 0; i <= detail; i++ )
					{
						var rad = Math.PI*2 * i / detail;
						this.points.push( { x: Math.sin(rad)*rx+this.cx, y: Math.cos(rad)*ry + this.cy, d: true } );
					}
				}
				
				this.mouseMove = function( x, y, isDown )
				{
					if( isDown ) {
						this.x = x;
						this.y = y;
						this.updatePoints( 60 );
					}
					return this.points;
				}
				this.mouseDown = function( x, y )
				{
					this.points = [];
					this.cx = this.x = x;
					this.cy = this.y = y;
					return this.points;
				}
				this.mouseUp = function( x, y )
				{
					this.x = x;
					this.y = y;
					this.updatePoints( 1080 );
					return this.points;
				}
			}
			*/
			function mouseDrawLine()
			{
				this.smooth = false;
				this.points = [];
				this.empty = function() { this.points = []; }
				this.mouseMove = function( x, y, isDown )
				{
					if( isDown ) {
						if( this.points.length > 1 ) this.points.shift() ;
						this.points.unshift( { x: x, y: y, d: isDown } ) ;
					}
					return this.points;
				}
				this.mouseDown = function( x, y )
				{
					this.points = [];
					this.points.unshift( { x: x, y: y, d: true } ) ;
					return this.points;
				}
				this.mouseUp = function( x, y )
				{
					if( this.points.length > 1 ) this.points.shift() ;
					this.points.unshift( { x: x, y: y, d: false } ) ;
					return this.points;
				}
			}
			
			function mouseDrawScribble()
			{
				this.smooth = true;
				this.points = [];
				this.empty = function() { this.points = []; }
				this.mouseMove = function( x, y, isDown )
				{
					if( isDown ) {
						this.points.unshift( { x: x, y: y, d: isDown } ) ;
					}
					return this.points;
				}
				this.mouseDown = function( x, y )
				{
					this.points = [];
					this.points.unshift( { x: x, y: y, d: true } ) ;
					return this.points;
				}
				this.mouseUp = function( x, y )
				{
					this.points.unshift( { x: x, y: y, d: false } ) ;
					return this.points;
				}
			}
			
			/**
			 * called on mouse movement
			 **/
			var mousePath = [];
			var mouseDown = false;
			var mouseDownSince = 0;
			var totalMovement = 0;
			var mouseX = 0;
			var mouseY = 0;
			var drawMode = 0;
			var drawController = new mouseDrawScribble();
			
			var selectMenu = null;
			var selectedShape = null;
			
			function showMenu( x, y )
			{
				menu.position( x - 25, y - 25 );
				menu.show();
				setTimeout( function() {
					menu.rootElement.onmouseover();
				}, 1 );
				lockedDrawing = true;
			}
			
			function hideMenu()
			{
				if( menu.visible ) {
					menu.hide( true );
					if( selectMenu != null )
					{
						menu.removeChild( selectMenu.id );
					}
					lockedDrawing = false;
				}
			}
			
			function selectShape( s )
			{
				s.isSelected = true;
				selectedShape = s;
				editPanel.shape = s;
				editPanel.show();
			}
			
			function deselectShape( )
			{
				if( selectedShape ) {
					selectedShape.isSelected = false;
				}
				selectedShape = null;
				editPanel.shape = null;
				editPanel.hide();
			}
			
			var delayedMenu = new delayed( function() {
				
				deselectShape();
				hideMenu();
				
				var shapes = shapeList.getShapesForPoint( [mouseX-offsetX, mouseY-offsetY] );
				if( shapes.length > 0 ) {
					selectMenu = menu.prependChild( 'opt-select', './icon_select.png', 'Select' );
					if( shapes.length > 1 ) {
						for( var i = 0; i < shapes.length; i++ ) {
							var menuItem = selectMenu.addChild( 'shape1', null, '#' + (i+1) );
							menuItem.shape = shapes[i];
							
							menuItem.onClick = function(e, el ) {
								hideMenu();
								selectShape( el.shape );
							}
						}
					}
					else {
						selectMenu.shape = shapes[0];
						selectMenu.onClick = function(e, el ) {
							hideMenu();
							selectShape( el.shape );
						}
					}
				}
				
				showMenu( mouseX, mouseY );
				drawController.empty();
				mouseDown = false;
			}, 1000 );
			
			function onMouseMove(e) {
				var t0 = performance.now();
				
				totalMovement += Math.abs( mouseX-e.clientX ) + Math.abs( mouseY-e.clientY );
				mouseX = e.clientX;
				mouseY = e.clientY;
				
				if( mouseDown && allowDrawing && !lockedDrawing  ) {
					drawController.mouseMove( mouseX, mouseY, mouseDown );
					if( totalMovement > 10 ) {
						delayedMenu.cancel();
					}
					/*
					var time = performance.now() - mouseDownSince;
					if( time > 1000 && totalMovement < 50 ) {
						menu.position( mouseX, mouseY );
						menu.show();
						menu.mouseover();
						mouseDown = false;
					}*/
				}
				
				var t1 = performance.now();
				fpsRenderTime += t1 - t0;
			}
			
			function onMouseDown(e)
			{
				var t0 = performance.now();
				
				totalMovement = 0;
				mouseDownSince = performance.now();
				mouseDown = true;
				var onScreen = mouseX >= 0 && mouseY >= 0 && mouseX < width && mouseY < height;
				if( onScreen && allowDrawing && !lockedDrawing  ) {
					
					drawController.empty();
					drawController.mouseDown( mouseX, mouseY );
					delayedMenu.trigger();
				}
				
				var t1 = performance.now();
				fpsRenderTime += t1 - t0;
			}
			
			function onMouseUp(e) 
			{
				var t0 = performance.now();
				//mousePath.unshift( { x: mouseX, y: mouseY, d: mouseDown, time: performance.now() } ) ;
				
				delayedMenu.cancel();
				var onScreen = mouseX >= 0 && mouseY >= 0 && mouseX < width && mouseY < height;
				if( onScreen && mouseDown && allowDrawing && !lockedDrawing ) {
					var time = performance.now() - mouseDownSince;
					//if( time > 1000 && totalMovement < 50 ) {
					//	menu.position( mouseX, mouseY );
					//	menu.show();
					//	menu.mouseover();
					//}
					//else {
						var pointsSource = drawController.mouseUp( mouseX, mouseY );
						var points = [];
						for( var i = 0; i < pointsSource.length; i++ )
						{
							points.push( [ (-offsetX + pointsSource[i].x-width/2)/radiusFactor, 
										   (-offsetY + pointsSource[i].y-height/2)/radiusFactor ] );
						}
						if( points.length > 1 ) {
							var s = new shapePointList([], drawController.smooth);
							s.setData( points );
							shapeList.add( s );
							shapeList.updateAutosave();
						}
					//}
					drawController.empty();
				}
				mouseDown = false;
				//mousePath = [];
				var t1 = performance.now();
				fpsRenderTime += t1 - t0;
			}
			
			
			/**
			 * called when new fft data is avabile
			 *
			 * @param data Array of 128 floats 
			 **/
			function onAudioData( data ) 
			{
				if( !hasInit ) {
					hasInit = true;
					onInit();
				}
				var t0 = performance.now();
				timer.start('audio update');
				
				try {
					
					// update data in the 2 frames
					frame2.update( data );
					if( !frame2.hasAudio && animateWhenSilent )
					{
						for( var i = 0; i < 64; i++ ) {
							var p = i / 63;
							var p2 = t0/(60*1000);
							var v = Math.sin( 23 * ( p + p2 ) * Math.PI*2 )+1;
								//v += Math.cos( -16 * ( p + p2/10 ) * Math.PI*2 + Math.PI )+1;
								//v += Math.sin( 32 * ( p + p2/15 ) * Math.PI*2 - Math.PI/2 )+1;
								v += Math.cos( -31 * ( p - p2 ) * Math.PI/3 )/2;
								//v += Math.cos( -4 * ( p + p2 ) * Math.PI*2 )+1;
							v/=2;
							data[i] = v;
							data[i+64] = v ;
						}
						frame2.update( data, true );
					}
				}
				catch(ex) { 
					console.error( ex.message );
				}				
				hadAudioFrame = true;
				timer.stop('audio update');
				var t1 = performance.now();
				fpsRenderTime += t1 - t0;
			}
		
			/**
			 * when document has been loaded, do all this stuff...
			 *   	- setup
			 * 		- register window resize event
			 * 		- register audio listener
			 * 		- set property listeners
			 * 		- queue first frame fro rendering
			 **/			
			window.onload = function() 
			{
				setup(); // setup anything not already setup
								
				window.addEventListener('resize', onResize ); // in case screen resizes
				window.addEventListener('mousemove', onMouseMove ); // in case screen resizes
				window.addEventListener('mousedown', onMouseDown ); // in case screen resizes
				window.addEventListener('mouseup', onMouseUp ); // in case screen resizes
				onResize(); // call it to have width and height set correctly

				// hook into wallpaper engins callback functions
				window.wallpaperPropertyListener = {
					applyUserProperties: function( p ) 
					{ 
						bgSettingsProxy.applyUserProperties( p );
						if( fnInitSlideshow ) fnInitSlideshow();
						// getColor(), getSlider(), getBool() can found in utils.js				
						//if( p.frame2Color ) {  frame2Color = getColor( p.frame2Color.value );  }
						try {
							/*if( p.backgroundColor ) { 
								bgColor = getColor( p.backgroundColor.value ); 
								bgTintElement.style.background = bgColor;
								document.body.style.background = bgColor + ' ' + ( bgImage ? 'url("file:///' + bgImage + '") center center no-repeat' : '' ) + ''; 
								document.body.style.backgroundSize = 'cover';
							}
							if( p.backgroundImage ) { 
								bgImage = p.backgroundImage.value;
								document.body.style.background = bgColor + ' ' + ( bgImage ? 'url("file:///' + bgImage + '") center center no-repeat' : '' ) + ''; 
								document.body.style.backgroundSize = 'cover';
							}
							if( p.backgroundTint ) { 
								backgroundTint = getSlider( p.backgroundTint.value, 0, 100 )/100;
								if( backgroundTint > 0 ) {
									bgTintElement.style.display = 'block';
									bgTintElement.style.opacity = backgroundTint;
								}
								else {									
									bgTintElement.style.display = 'none';
								}
							}*/
							
							if( p.rotation ) { baseRotation = getSlider( p.rotation.value, -180, 180 ); }
							if( p.positionX ) {  offsetX = getSlider( p.positionX.value, -3000, 3000 ); }  
							if( p.positionY ) {  offsetY = getSlider( p.positionY.value, -3000, 3000 ); }  
							if( p.freqScaleAdjustment ) {  
								freqScaleAdjustment = getSlider( p.freqScaleAdjustment.value, -100, 100 );
								
								if( freqScaleAdjustment < 0 ) {								
									freqScaleAdjustment = -( 1 + freqScaleAdjustment / -100 );
								}
								else if( freqScaleAdjustment == 0 ) {								
									freqScaleAdjustment = 0;
								}
								else {
									freqScaleAdjustment = ( 1 + freqScaleAdjustment / 100 );
								}
								
								shapeList.resetPreperation();
							} 
							if( p.freqScaleAdjustmentAnim ) {  
								freqScaleAdjustmentAnim = getBool( p.freqScaleAdjustmentAnim.value ); 
								shapeList.resetPreperation();
							}
							
							if( p.render ) {
								renderMethod = getSlider( p.render.value, 1, 9 );
							}
							if(  p.shape ) {
								var shape = p.shape.value;
								if( defaultGenerators.hasOwnProperty( shape ) ) {
									var gen = new defaultGenerators[shape]();
									gen.generate( shapeList );
									if( hasInit ) shapeList.updateAutosave();
								}
								else {										
									if( !shapeList.defaultShapes.hasOwnProperty( shape ) ) {
										shape = 'circle';
									}
									if( shapeList.defaultShapes.hasOwnProperty( shape ) ) {
										shapeList.empty();
										shapeList.createShape( shape );
										if( hasInit ) shapeList.updateAutosave();
									}
								}
							}
							
							if( p.interpolation ) { interpolationSteps = getSlider( p.interpolation.value, 1, 10 );  } 
							if( p.interpolationBalanced ) { interpolationBalanced = getBool( p.interpolationBalanced.value );  } 
							
							if( p.eq1 ) {  frame2.config.eqFreq1 = getSlider( p.eq1.value, 0, 220 ) * 100; if(initialized) lastEqChange = performance.now(); }  
							if( p.eq2 ) {  frame2.config.eqFreq2 = getSlider( p.eq2.value, 0, 220 ) * 100; if(initialized) lastEqChange = performance.now(); }  
							if( p.eq3 ) {  frame2.config.eqFreq3 = getSlider( p.eq3.value, 0, 220 ) * 100; if(initialized) lastEqChange = performance.now(); }  
							if( p.eq1Strength ) {  frame2.config.eqFreq1Strength = getSlider( p.eq1Strength.value, 0, 100 ) / 100; if(initialized) lastEqChange = performance.now(); }  
							if( p.eq2Strength ) {  frame2.config.eqFreq2Strength = getSlider( p.eq2Strength.value, 0, 100 ) / 100; if(initialized) lastEqChange = performance.now(); }  
							if( p.eq3Strength ) {  frame2.config.eqFreq3Strength = getSlider( p.eq3Strength.value, 0, 100 ) / 100; if(initialized) lastEqChange = performance.now(); }  
							if( p.eqWidth ) {  frame2.config.eqWidth = getSlider( p.eqWidth.value, 0, 30 ) ; if(initialized) lastEqChange = performance.now(); }  
							if( p.eqStrength ) {  frame2.config.eqStrength = getSlider( p.eqStrength.value, 0, 100 ) / 100 ; if(initialized) lastEqChange = performance.now(); }  
							
							if( p.reverseAudio ) {  frame2.config.reverseFreq = getBool( p.reverseAudio.value ); }  // actually a combo, but this works too
							if( p.frame2Pow ) {  frame2.config.powerOf = getSlider( p.frame2Pow.value, 0, 100 ); }  // actually a combo, but this works too
							if( p.outline ) {  useOutline = getBool( p.outline.value ); }  
							if( p.radius ) {  radiusFactor = getSlider( p.radius.value, 1, 1000 )/100; }  // actually a combo, but this works too
							if( p.height ) {  
								var h = getSlider( p.height.value, 1, 100 )/100; 
								h -= 0.01; h /= 0.99; h = Math.pow( h, 2 ); h *= 0.99; h += 0.01;
								frame2.config.ampFactor = h;
								heightCutoff = cfgHeightCutoff * frame2.config.ampFactor; 
								heightCutoff = heightCutoff * heightCutoff;
							} 
							if( p.heightCutoff ) {  
								cfgHeightCutoff = getSlider( p.heightCutoff.value, 1, 100 ); 
								heightCutoff = cfgHeightCutoff * frame2.config.ampFactor; 
								heightCutoff = heightCutoff * heightCutoff;
							}  
							
							//if( p.frame2Normalize ) {  frame2.config.normalize = getBool( p.frame2Normalize.value );  }
							//if( p.frame2MotionBlur ) {  frame2.config.motionBlur = getBool( p.frame2MotionBlur.value );  }
							//if( p.frame2Smooth ) {  frame2.config.smooth = getBool( p.frame2Smooth.value );  }
							
							//if( p.frame2NormalizeAmount ) {  frame2.config.normalizeFactor = 1 - getSlider( p.frame2NormalizeAmount.value, 0, 100 ) / 100;  }
							if( p.frame2MotionBlurAmount ) {  frame2.config.motionBlurFactor = 1 - getSlider( p.frame2MotionBlurAmount.value, 0, 100 ) / 100;  }
							//if( p.frame2SmoothAmount ) {  frame2.config.smoothFactor = getSlider( p.frame2SmoothAmount.value, 0, 100 ) / 100;  }
							
							// options
							//if( p.optionsUserFps ) {  targetFramerateUser = getSlider( p.optionsUserFps.value, 0, 1000 ) ;   }  // actually a combo, but this works too
							//if( p.optionRenderMethod ) { renderFunction = p.optionRenderMethod.value; }
							
							if( p.animateWhenSilent ) {  animateWhenSilent = getBool( p.animateWhenSilent.value ); } 
							if( p.animateWhenSilentHeight ) {  
								var h = getSlider( p.animateWhenSilentHeight.value, 1, 100 )/100; 
								h -= 0.01; h /= 0.99; h = Math.pow( h, 2 ); h *= 0.99; h += 0.01;
								animateWhenSilentHeight = h;
							} 
							
							if( p.allowDrawing ) {  allowDrawing = getBool( p.allowDrawing.value ); }  

							//if( p.heightDir ) {  heightDir = getSlider( p.heightDir.value, 1, 3 );  } 
							if( p.cpuCores ) {  cpuCores = getSlider( p.cpuCores.value, 1, 16 );  } 
							if( p.cpuPercWarning ) {  cpuWarningAt = getSlider( p.cpuPercWarning.value, 1, 100 );  } 
							
							if( p.colorRotation ) { colorRotation = getBool( p.colorRotation.value ); }
							if( p.colorGradient ) { colorGradient = getSlider( p.colorGradient.value, 0, 3 ); }
							if( p.color1 ) { color1 = getColorAsArray( p.color1.value ); color1 = rgbToHsl( color1[0], color1[1], color1[2], 255 ); }
							if( p.color2 ) { color2 = getColorAsArray( p.color2.value ); color2 = rgbToHsl( color2[0], color2[1], color2[2], 255 ); }
							if( p.color3 ) { color3 = getColorAsArray( p.color3.value ); color3 = rgbToHsl( color3[0], color3[1], color3[2], 255 ); }
							
							if( p.colorGlow ) { 
								colorGlow = getSlider( p.colorGlow.value, 0, 20 ); 
								if( colorGlow == 0 ) canvasBg.style.display = 'none';
								else canvasBg.style.display = 'block';
								if( colorGlow >=1 ) colorGlow += 1;
								canvasBg.style.filter = 'blur(' + colorGlow + (colorGlow ? 'px' : '' ) + ')';
							}
							if( p.colorGlowStrength ) { 
								colorGlowStrength = getSlider( p.colorGlowStrength.value, 1, 3 ); 
							}
							
			
						}
						catch( ex ) { console.log( ex.message ); }
					},
					applyGeneralProperties: function( p ) 
					{
						//console.log( 'applyGeneralProperties' );
						if( p.fps ) {
							// this is the fps setting as users configured it in wallpaper engine
							targetFramerate = p.fps;
						}
					},
					setPaused: function( p ) 
					{ 
						//console.log( 'setPaused' );
						isPaused = p ;
						bgSettingsProxy.setPaused( p );
					},
				    userDirectoryFilesAddedOrChanged: function( propertyName, changedFiles ) 
				    {
						//console.log( 'userDirectoryFilesAddedOrChanged' );
				    	bgSettingsProxy.userDirectoryFilesAddedOrChanged( propertyName, changedFiles );
				    },
				    userDirectoryFilesRemoved: function(propertyName, removedFiles) 
				    {
						//console.log( 'userDirectoryFilesRemoved' );
				    	bgSettingsProxy.userDirectoryFilesRemoved( propertyName, removedFiles );
				    }
				};
				
				// register our own audio event
				if( window.wallpaperRegisterAudioListener ) {
					window.wallpaperRegisterAudioListener( onAudioData );
				}
				else {
					console.error( 'can\'t register audio listener' );
				}
				
				// start render loop by requesting first frame
				window.requestAnimationFrame( render );
			}
			
			var svgSource;
			/*
			var ajax = new XMLHttpRequest();
			ajax.open("GET", "thunderdome-2.svg", true);
			ajax.send();
			ajax.onload = function(e) {
				svgSource = new SvgSource( ajax.responseText );
			}*/
			function SvgSource( src, cbUpdate, cbComplete )
			{
				var self = this;
				var minX = Number.POSITIVE_INFINITY,
					minY = Number.POSITIVE_INFINITY,
					maxX = Number.NEGATIVE_INFINITY,
					maxY = Number.NEGATIVE_INFINITY;
					
				var parser = new DOMParser();
				var doc = parser.parseFromString(src, "image/svg+xml");
				//flatten( doc.getElementsByTagName('svg')[0] );
				var paths = doc.getElementsByTagName('path');				
				this.pointLists = [];
				this.totalPaths = paths.length;
				this.currentPath = 0;
				/*
				for( var i = 0; i < paths.length; i++ ) {
					var pathEl = paths[i];
					var pts = [];
					var pathLen = pathEl.getTotalLength();
					
					for( var j = 0; j <= (1024); j++ ){
						var pt = pathEl.getPointAtLength( pathLen * j / (1024) );
						var x = pt.x;
						var y = pt.y;
						if( x < minX ) minX = x;
						if( y < minY ) minY = y;
						if( x > maxX ) maxX = x;
						if( y > maxY ) maxY = y;
						pts.push([x, y]);
						if( x == 0 && y == 0 ) console.log( 'busted' );
					}
					this.pointLists.push( pts );
				}
				*/
				var onComplete = function()
				{
					var dx = maxX - minX;
					var dy = maxY - minY;
					var d = Math.max( dx, dy );
					var d2 = Math.min( dx, dy );
					
					var dx1 = 1;
					var dy1 = 1;
					if( d == dx ) {
						dy1 = dy / dx;
					}
					else {
						dx1 = dx / dy;
					}
					
						
					for( var i = 0; i < self.pointLists.length; i++ ) {
						var points = self.pointLists[i];	
						for( var j = 0; j < points.length; j++ )
						{
							points[j][0] = ( ( points[j][0] - minX ) / dx ) * dx1 * 400 - 200 * dx1;
							points[j][1] = ( ( points[j][1] - minY ) / dy ) * dy1 * 400 - 200 * dy1;
						}
					}
				
					if( hasInit ) {
						self.toShapeList( shapeList );
					}
					if( cbComplete ) cbComplete();
				}
				
					
				var delayedIteration = new delayed( function()
				{
					var pathEl = paths[self.currentPath];
					var pts = [];
					var pathLen = pathEl.getTotalLength();
					
					for( var j = 0; j <= (1024); j++ ){
						var pt = pathEl.getPointAtLength( pathLen * j / (1024) );
						var x = pt.x;
						var y = pt.y;
						if( x < minX ) minX = x;
						if( y < minY ) minY = y;
						if( x > maxX ) maxX = x;
						if( y > maxY ) maxY = y;
						pts.push([x, y]);
					}
					self.pointLists.push( pts );
					
					self.currentPath++;
					if( self.currentPath < self.totalPaths ) delayedIteration.trigger();
					else onComplete();
					if( cbUpdate ) cbUpdate( self.currentPath / self.totalPaths );
				}, 1 );
				delayedIteration.trigger();
				 
				this.toShapeList = function( shapeList )
				{
					drawController.empty();
					shapeList.empty();
					for( var i = 0; i < this.pointLists.length; i++ ) {
						var points = this.pointLists[i];
						var s = new shapePointList( );
						s.setData( points );
						shapeList.add(s);
					}
				}
			}
		</script>
	</body>
</html>
